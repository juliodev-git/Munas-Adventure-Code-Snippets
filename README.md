# Muna's Adventure
![screenshot](screenshot.png)
[Read More About Muna's Adventure](https://portfolium.com/entry/munas-adventure)


_______________________________________

**Muna's Adventure** is a third-person shooter with an emphasis on scavenging items from your environment to increase your chances of survival. The goal of the game is to defeat enemies to progress through the story, using a variety of consumables, plants, rations and ammunition to aid you in your quest!

_______________________________________

I challenged myself to create a fully playable prototype in one year. In that time, I developed an interactable inventory of items, specialized to store a list of instantiated scriptable objects labeled as 'items.' Using the properties of inheritance, sub-items were created that were compatible with the UI Inventory Controller System and still behave in their own unique way such as: ammunition items that reload to and fire from your weapon, or consumable items that can be used in-game to heal the player or provide defensive buffs. Additionally, I crafted all animations and made them with animation masking in mind - allowing us to use the same base animations with alternate arm animations that change depending on the weapon being used. The firing system was made using Unity's particle system with collision enabled. Adjustments to the particle system were made to account for firing speed, ricochets and aim variance - the same bullet asset being used by all firing entities by limiting bullet collision detectiom from the firing entity. Similar to bullets, an explosive grenade was created following the same collision detection properties, however these grenades have the special property of applying forces to rigidbodies in its vicinity. To wrap up the game up, I made cinematic cutscenes to introduce the characters, their immediate goals, and to drop additional information about the world as well.

_______________________________________

**Bullet.cs**: This script is attached to a particle system. Using OnParticleCollision, we can detect any colliders that were hit by our bullet particle and interact with them. In our case, we simply deduct health from any HealthControllers attached to GameObjects. The HealthController handles it from there.

**HealthController.cs**: HealthController tracks an entity's health and allows for health manipulation via damage from bullets, grenades, slashes or the healing effects of consumables. A delegate is used to trigger any events that come from an entitie's death or changes to an entities health. For the player, health updates trigger the UI to update the health bar. The OnDie delegate is used to trigger a game over. For any other entities, only the OnDie delegate is used: either to spawn loot from the enemy, or instantiate an explosion followed by object destruction.

**Human.cs**: The Human class is primarily used to give control of a player entity to the user (in our case, the player entity is Muna). This class also communicates player states to player-dependent components such as UI menus and in-game pickups: for UI menus, some menus will not open if the player is damaged or reloading - pickups and lootables also need a target to add themselves too, and Human offers a link from Muna (the player entity) to our users item list. Input values such as joystick and button presses are checked here and sent to the player entity, along with camera rotation information, to move the character relative to the camera. For aiming and firing purposes, the player can be rotated to face the same direction as the camera as well. Camera component values are also changed here based on button presses for example, if the player is holding the 'aim' button, the camera will zoom in to make target finding easier.

**InventoryScriptableObject.cs**: The InventoryScriptableObject maintains a list of items, storing any changes made to it to PlayerPrefs - allowing for a live and up-to-date instance of the players inventory. By using a class specifically for holding a list (InventoryClass), we can store the list of items as a JSON string to PlayerPrefs. Data manipulation functions can be used by any component that adds to, removes from, or positionally changes the player inventory such as: the inventory/looting menu, pickup objects, or item triggers that consume an item to activate an in-game effect.

**Item.cs**: Items, in their simplest form, are sprites of their item image as well as a reference to their scriptbale-object-version called 'sourceItem.' All items have itemCounts as well, however by default, items can only be 1 unless otherwise specified (for example, bullets are stackable and can hold more than 1). Since items are instantiated versions of scriptableObjects, a reference to the source item is required when trying to make copies of this item in-game (can not reliablty make instances of instances).

**ItemController.cs**: The ItemController uses input to: move items between valid slot locations across all open slots in the active UI inventory panel and has access to the currently selectable UI object, validating the selectable UI object as an item. Upon making any visual changes to the player's inventory, this script will update the underlying data version of the inventory to match what the player has done in the UI inventory menu.

**Player.cs**: The Player script is in charge of making any changes to the main player entity (Muna). If Muna is damaged, hit by a grenade, trys to loot, or consumes an item, then any animation triggers are sent here and reflected onto her animation state. The Player's link to the Human script allows us to block certain behaviours of overhead mechanics such as menu item manipulation while reloading, hanging on a cliff, or in a damaged state. Other environmental values are found here, such as slope angles that prevent the player from running up steep inclines or perpendicular walls that can be climbed. Rotational changes are also made here based on the player's animation: by default the player faces the direction of camera-relative input, but other animations like slashing, throwing, or firing, require the player face the same direction of the camera or the input. Certain animations can also flip the animation to oppose input, or slow rotational speed. This script also offers player bone transform positions for instatiating throwables, bullets, or consumables. Links to HealthController and StaminaController have also been made to limit player movement when all stamina has been exhasuted or the player dies.
